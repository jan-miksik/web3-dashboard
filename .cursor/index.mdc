---
description: General project rules and coding standards
alwaysApply: true
---

# General Project Rules

## Logging

**NEVER use `console.log`, `console.error`, `console.warn`, or any other `console.*` methods directly.**

- Always use the centralized `logger` utility from `~/utils/logger`
- The logger provides consistent formatting, log levels, and can be configured per environment
- Example:
  ```typescript
  import { logger } from '~/utils/logger'
  
  // ✅ Correct
  logger.info('User logged in', { userId: user.id })
  logger.error('Failed to fetch data', { error, context })
  logger.warn('Deprecated API used', { endpoint })
  logger.debug('Processing request', { requestId })
  
  // ❌ Wrong
  console.log('User logged in')
  console.error('Failed to fetch data')
  ```

## Error Handling

**NEVER throw raw errors or use `throw new Error()` directly.**

- Always use the centralized `handleError` function from `~/utils/error-handler`
- The error handler provides:
  - Consistent error formatting
  - User-friendly error messages
  - Automatic error notifications (toast/notification system)
  - Error logging
  - Error tracking integration (if configured)
- Example:
  ```typescript
  import { handleError } from '~/utils/error-handler'
  
  // ✅ Correct
  try {
    await fetchData()
  } catch (error) {
    handleError(error, {
      message: 'Failed to load wallet data',
      context: { walletAddress },
      showNotification: true,
    })
  }
  
  // ❌ Wrong
  try {
    await fetchData()
  } catch (error) {
    throw error
    // or
    throw new Error('Something went wrong')
  }
  ```

## TypeScript Types

**NEVER use `any` type in TypeScript code.**

- Always use proper types, interfaces, or `unknown` when the type is truly unknown
- Use type guards and type assertions when necessary
- Prefer `unknown` over `any` when dealing with external data
- Example:
  ```typescript
  // ✅ Correct
  import { handleError } from '~/utils/error-handler'
  
  interface UserData {
    id: string
    name: string
  }
  
  function processUser(data: unknown): UserData {
    if (isUserData(data)) {
      return data
    }
    const error = new Error('Invalid user data')
    handleError(error, {
      message: 'Invalid user data',
      context: { data },
    })
    throw error
  }
  
  // ❌ Wrong
  function processUser(data: any): any {
    return data
  }
  ```

## DRY Principle (Don't Repeat Yourself)

- Extract common logic into reusable functions, composables, or utilities
- Create shared components for repeated UI patterns
- Use constants for magic numbers and strings
- Avoid duplicating code - if you find yourself copying code, refactor it
- Example:
  ```typescript
  // ✅ Correct - reusable utility
  // utils/format.ts
  export function formatAddress(address: string): string {
    return `${address.slice(0, 6)}...${address.slice(-4)}`
  }
  
  // ❌ Wrong - duplicated logic
  const shortAddress1 = `${address1.slice(0, 6)}...${address1.slice(-4)}`
  const shortAddress2 = `${address2.slice(0, 6)}...${address2.slice(-4)}`
  ```

## Frontend DApp Development Rules

### Language & Type Safety

- **All JavaScript/Frontend code must be in TypeScript**
- Enforce strict mode for type safety
- Never use `any` type (see TypeScript Types section above)

### Chain Interaction

**NEVER use `ethers.js`. Always use Viem for all low-level contract interaction and data formatting.**

- Use Viem for:
  - Contract interactions
  - Data formatting (addresses, numbers, etc.)
  - Transaction building
  - Event parsing
- Example:
  ```typescript
  // ✅ Correct - using Viem
  import { formatEther, parseEther } from 'viem'
  const balance = formatEther(bigIntValue)
  
  // ❌ Wrong - using ethers.js
  import { ethers } from 'ethers'
  const balance = ethers.formatEther(bigIntValue)
  ```

### Testing Stack

- **Unit/Integration Tests:**
  - Use **Vitest** with framework-specific testing libraries
  - For Vue: Use **Vue Test Utils** (already configured)
  - Write tests for all composables, utilities, and components
  - Aim for high test coverage

- **E2E Tests:**
  - Use **Playwright** with Web3 helpers like **Synpress**
  - Tests must run against a local **Anvil** fork
  - Test real wallet interactions and transactions

### Framework-Specific Rules (Nuxt/Vue)

- **Vue 3 Composition API:**
  - Always use `<script setup>` syntax
  - Use Composition API (`ref`, `computed`, `watch`, etc.)
  - Avoid Options API unless necessary

- **Nuxt 3 Features:**
  - Leverage Nuxt's built-in features:
    - Auto-imports (no need to import `ref`, `computed`, etc.)
    - `useFetch` and `useAsyncData` for data fetching
    - `useRuntimeConfig` for environment variables
    - `useRoute` and `useRouter` for routing
  - Use **Nuxt UI** or similar component libraries for consistent UI

- **State Management:**
  - Use **Wagmi** for Web3 state management
  - Use **TanStack Query** (via Wagmi) for async chain data
  - Use composables for shared business logic
  - Example:
    ```typescript
    // ✅ Correct - using Wagmi with TanStack Query
    import { useConnection } from '@wagmi/vue'
    const { address, isConnected } = useConnection({ config })
    
    // ✅ Correct - using Nuxt composables
    const { data, error } = useFetch('/api/zerion/positions')
    ```

## Component Architecture & Splitting

**Components should be kept small and focused. Large components must be split into smaller, reusable parts.**

### Component Size Guidelines

- **Maximum component size:** Components should not exceed ~300-400 lines of code (including template, script, and styles)
- **If a component exceeds this limit:** Split it into smaller sub-components and extract business logic into composables

### When to Split Components

1. **Component exceeds ~300-400 lines:** Break it down into smaller, focused components
2. **Repeated UI patterns:** Extract into reusable sub-components
3. **Complex business logic:** Move logic to composables (hooks) in `~/composables` directory
4. **Multiple responsibilities:** Split into separate components, each handling one concern
5. **Large template sections:** Extract distinct UI sections into their own components

### How to Split Components

1. **Extract business logic to composables:**
   - Move state management, computed properties, watchers, and functions to a composable
   - Keep components focused on presentation and user interaction
   - Example: `useTokenList.ts` composable for TokenList component logic

2. **Create focused sub-components:**
   - Extract distinct UI sections (header, table, filters, states) into separate components
   - Each sub-component should have a single, clear responsibility
   - Example: `TokenListHeader.vue`, `TokenTable.vue`, `TokenRow.vue`, `NetworkFilter.vue`

3. **Component structure:**
   ```
   LargeComponent.vue (orchestrator)
   ├── ComponentHeader.vue (header section)
   ├── ComponentTable.vue (table/list section)
   ├── ComponentFilter.vue (filter section)
   └── ComponentStates.vue (empty/error/loading states)
   ```

### Example Structure

```vue
<!-- ✅ Correct - Small, focused component using composable -->
<script setup lang="ts">
import { useTokenList } from '~/composables/useTokenList'

const {
  tokens,
  isLoading,
  error,
  // ... other properties and methods
} = useTokenList()
</script>

<template>
  <div class="token-list">
    <TokenListHeader ... />
    <TokenListStates ... />
    <TokenTable ... />
  </div>
</template>
```

```vue
<!-- ❌ Wrong - Large monolithic component with all logic -->
<script setup lang="ts">
// 200+ lines of business logic mixed with component code
const tokens = ref([])
const isLoading = ref(false)
// ... many more state variables and functions
</script>

<template>
  <!-- 500+ lines of template with nested logic -->
</template>
```

### Benefits of Component Splitting

- **Maintainability:** Easier to understand and modify smaller components
- **Reusability:** Sub-components can be reused in other contexts
- **Testability:** Smaller components are easier to test in isolation
- **Performance:** Better code splitting and tree-shaking
- **Collaboration:** Multiple developers can work on different components simultaneously

## Additional Best Practices

- Use meaningful variable and function names
- Keep functions small and focused on a single responsibility
- Add JSDoc comments for public APIs and complex functions
- Follow the existing code style and formatting
- Write tests for new features and bug fixes
- Use async/await instead of promises chains when possible
- Prefer composition over inheritance
- Keep components and composables focused and reusable
